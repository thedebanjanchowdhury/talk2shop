{"version":3,"file":"client.d.ts","names":["Assistant","AssistantGraph","AssistantSortBy","AssistantSelectField","AssistantVersion","AssistantsSearchResponse","CancelAction","Checkpoint","Config","Cron","CronSelectField","CronCreateForThreadResponse","CronCreateResponse","CronSortBy","DefaultValues","GraphSchema","Item","ListNamespaceResponse","Metadata","Run","RunSelectField","RunStatus","SearchItemsResponse","SortOrder","Subgraphs","Thread","ThreadSelectField","ThreadSortBy","ThreadState","ThreadStatus","ThreadValuesFilter","Command","CronsCreatePayload","OnConflictBehavior","RunsCreatePayload","RunsStreamPayload","RunsWaitPayload","StreamEvent","StreamMode","ThreadStreamMode","TypedAsyncGenerator","AsyncCaller","AsyncCallerParams","HeaderValue","getApiKey","RequestHook","URL","RequestInit","Promise","ClientConfig","Record","BaseClient","AbortSignal","T","Response","CronsClient","AssistantsClient","ThreadsClient","TStateType","ValuesType","Array","TUpdateType","Pick","Omit","Partial","AsyncGenerator","RunsClient","TStreamMode","TSubgraphs","TCustomEventType","StoreClient","UiClient","Client","getClientConfigHash"],"sources":["../src/client.d.ts"],"sourcesContent":["import { Assistant, AssistantGraph, AssistantSortBy, AssistantSelectField, AssistantVersion, AssistantsSearchResponse, CancelAction, Checkpoint, Config, Cron, CronSelectField, CronCreateForThreadResponse, CronCreateResponse, CronSortBy, DefaultValues, GraphSchema, Item, ListNamespaceResponse, Metadata, Run, RunSelectField, RunStatus, SearchItemsResponse, SortOrder, Subgraphs, Thread, ThreadSelectField, ThreadSortBy, ThreadState, ThreadStatus, ThreadValuesFilter } from \"./schema.js\";\nimport type { Command, CronsCreatePayload, OnConflictBehavior, RunsCreatePayload, RunsStreamPayload, RunsWaitPayload, StreamEvent } from \"./types.js\";\nimport type { StreamMode, ThreadStreamMode, TypedAsyncGenerator } from \"./types.stream.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\ntype HeaderValue = string | undefined | null;\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument (if string)\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - API key provided as an argument. If null, skips environment lookup. If undefined, tries environment.\n * @returns The API key if found, otherwise undefined\n */\nexport declare function getApiKey(apiKey?: string | null): string | undefined;\nexport type RequestHook = (url: URL, init: RequestInit) => Promise<RequestInit> | RequestInit;\nexport interface ClientConfig {\n    apiUrl?: string;\n    /**\n     * API key for authentication.\n     * - If a string is provided, that key will be used\n     * - If undefined (default), the key will be auto-loaded from environment variables (LANGGRAPH_API_KEY, LANGSMITH_API_KEY, or LANGCHAIN_API_KEY)\n     * - If null, no API key will be set (skips auto-loading)\n     */\n    apiKey?: string | null;\n    callerOptions?: AsyncCallerParams;\n    timeoutMs?: number;\n    defaultHeaders?: Record<string, HeaderValue>;\n    onRequest?: RequestHook;\n}\ndeclare class BaseClient {\n    protected asyncCaller: AsyncCaller;\n    protected timeoutMs: number | undefined;\n    protected apiUrl: string;\n    protected defaultHeaders: Record<string, HeaderValue>;\n    protected onRequest?: RequestHook;\n    constructor(config?: ClientConfig);\n    protected prepareFetchOptions(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        withResponse?: boolean;\n    }): [url: URL, init: RequestInit];\n    protected fetch<T>(path: string, options: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal: AbortSignal | undefined;\n        withResponse: true;\n    }): Promise<[T, Response]>;\n    protected fetch<T>(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal: AbortSignal | undefined;\n        withResponse?: false;\n    }): Promise<T>;\n}\nexport declare class CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    createForThread(threadId: string, assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateForThreadResponse>;\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    create(assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateResponse>;\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    delete(cronId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    search(query?: {\n        assistantId?: string;\n        threadId?: string;\n        limit?: number;\n        offset?: number;\n        sortBy?: CronSortBy;\n        sortOrder?: SortOrder;\n        select?: CronSelectField[];\n        signal?: AbortSignal;\n    }): Promise<Cron[]>;\n    /**\n     * Count cron jobs matching filters.\n     *\n     * @param query.assistantId Assistant ID to filter by.\n     * @param query.threadId Thread ID to filter by.\n     * @returns Number of cron jobs matching the criteria.\n     */\n    count(query?: {\n        assistantId?: string;\n        threadId?: string;\n        signal?: AbortSignal;\n    }): Promise<number>;\n}\nexport declare class AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    get(assistantId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    getGraph(assistantId: string, options?: {\n        xray?: boolean | number;\n        signal?: AbortSignal;\n    }): Promise<AssistantGraph>;\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    getSchemas(assistantId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<GraphSchema>;\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    getSubgraphs(assistantId: string, options?: {\n        namespace?: string;\n        recurse?: boolean;\n        signal?: AbortSignal;\n    }): Promise<Subgraphs>;\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    create(payload: {\n        graphId: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        assistantId?: string;\n        ifExists?: OnConflictBehavior;\n        name?: string;\n        description?: string;\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    update(assistantId: string, payload: {\n        graphId?: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        name?: string;\n        description?: string;\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    delete(assistantId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants or, when includePagination is true, a mapping with the assistants and next cursor.\n     */\n    search(query: {\n        graphId?: string;\n        name?: string;\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        sortBy?: AssistantSortBy;\n        sortOrder?: SortOrder;\n        select?: AssistantSelectField[];\n        includePagination: true;\n        signal?: AbortSignal;\n    }): Promise<AssistantsSearchResponse>;\n    search(query?: {\n        graphId?: string;\n        name?: string;\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        sortBy?: AssistantSortBy;\n        sortOrder?: SortOrder;\n        select?: AssistantSelectField[];\n        includePagination?: false;\n        signal?: AbortSignal;\n    }): Promise<Assistant[]>;\n    /**\n     * Count assistants matching filters.\n     *\n     * @param query.metadata Metadata to filter by. Exact match for each key/value.\n     * @param query.graphId Optional graph id to filter by.\n     * @param query.name Optional name to filter by.\n     * @returns Number of assistants matching the criteria.\n     */\n    count(query?: {\n        metadata?: Metadata;\n        graphId?: string;\n        name?: string;\n        signal?: AbortSignal;\n    }): Promise<number>;\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    getVersions(assistantId: string, payload?: {\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        signal?: AbortSignal;\n    }): Promise<AssistantVersion[]>;\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    setLatest(assistantId: string, version: number, options?: {\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n}\nexport declare class ThreadsClient<TStateType = DefaultValues, TUpdateType = TStateType> extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    get<ValuesType = TStateType>(threadId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Thread<ValuesType>>;\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    create(payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * ID of the thread to create.\n         *\n         * If not provided, a random UUID will be generated.\n         */\n        threadId?: string;\n        /**\n         * How to handle duplicate creation.\n         *\n         * @default \"raise\"\n         */\n        ifExists?: OnConflictBehavior;\n        /**\n         * Graph ID to associate with the thread.\n         */\n        graphId?: string;\n        /**\n         * Apply a list of supersteps when creating a thread, each containing a sequence of updates.\n         *\n         * Used for copying a thread between deployments.\n         */\n        supersteps?: Array<{\n            updates: Array<{\n                values: unknown;\n                command?: Command;\n                asNode: string;\n            }>;\n        }>;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Thread<TStateType>>;\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    copy(threadId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Thread<TStateType>>;\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    update(threadId: string, payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Thread>;\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    delete(threadId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    search<ValuesType = TStateType>(query?: {\n        /**\n         * Metadata to filter threads by.\n         */\n        metadata?: Metadata;\n        /**\n         * Filter by specific thread IDs.\n         */\n        ids?: string[];\n        /**\n         * Maximum number of threads to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         */\n        offset?: number;\n        /**\n         * Thread status to filter on.\n         */\n        status?: ThreadStatus;\n        /**\n         * Sort by.\n         */\n        sortBy?: ThreadSortBy;\n        /**\n         * Sort order.\n         * Must be one of 'asc' or 'desc'.\n         */\n        sortOrder?: SortOrder;\n        /**\n         * Array of fields to select.\n         * Elements or array must be one of 'thread_id, 'created_at', 'updated_at', 'metadata', 'config', 'context', 'status', 'values', or 'interrupts'.\n         */\n        select?: ThreadSelectField[];\n        /**\n         * Values to filter threads by.\n         */\n        values?: ThreadValuesFilter;\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Thread<ValuesType>[]>;\n    /**\n     * Count threads matching filters.\n     *\n     * @param query.metadata Thread metadata to filter on.\n     * @param query.values State values to filter on.\n     * @param query.status Thread status to filter on.\n     * @returns Number of threads matching the criteria.\n     */\n    count<ValuesType = TStateType>(query?: {\n        metadata?: Metadata;\n        values?: ValuesType;\n        status?: ThreadStatus;\n        signal?: AbortSignal;\n    }): Promise<number>;\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    getState<ValuesType = TStateType>(threadId: string, checkpoint?: Checkpoint | string, options?: {\n        subgraphs?: boolean;\n        signal?: AbortSignal;\n    }): Promise<ThreadState<ValuesType>>;\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    updateState<ValuesType = TUpdateType>(threadId: string, options: {\n        values: ValuesType;\n        checkpoint?: Checkpoint;\n        checkpointId?: string;\n        asNode?: string;\n        signal?: AbortSignal;\n    }): Promise<Pick<Config, \"configurable\">>;\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    patchState(threadIdOrConfig: string | Config, metadata: Metadata, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    getHistory<ValuesType = TStateType>(threadId: string, options?: {\n        limit?: number;\n        before?: Config;\n        checkpoint?: Partial<Omit<Checkpoint, \"thread_id\">>;\n        metadata?: Metadata;\n        signal?: AbortSignal;\n    }): Promise<ThreadState<ValuesType>[]>;\n    joinStream(threadId: string, options?: {\n        lastEventId?: string;\n        streamMode?: ThreadStreamMode | ThreadStreamMode[];\n        signal?: AbortSignal;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n}\nexport declare class RunsClient<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> extends BaseClient {\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: null, assistantId: string, payload?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, \"multitaskStrategy\" | \"onCompletion\">): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: string, assistantId: string, payload?: RunsStreamPayload<TStreamMode, TSubgraphs>): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    create(threadId: string | null, assistantId: string, payload?: RunsCreatePayload): Promise<Run>;\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    createBatch(payloads: (Omit<RunsCreatePayload, \"signal\"> & {\n        assistantId: string;\n    })[], options?: {\n        signal?: AbortSignal;\n    }): Promise<Run[]>;\n    wait(threadId: null, assistantId: string, payload?: Omit<RunsWaitPayload, \"multitaskStrategy\" | \"onCompletion\">): Promise<ThreadState[\"values\"]>;\n    wait(threadId: string, assistantId: string, payload?: RunsWaitPayload): Promise<ThreadState[\"values\"]>;\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    list(threadId: string, options?: {\n        /**\n         * Maximum number of runs to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         * Defaults to 0.\n         */\n        offset?: number;\n        /**\n         * Status of the run to filter by.\n         */\n        status?: RunStatus;\n        select?: RunSelectField[];\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Run[]>;\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    get(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Run>;\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    cancel(threadId: string, runId: string, wait?: boolean, action?: CancelAction, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    join(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<TStateType>;\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     *\n     * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    joinStream(threadId: string | undefined | null, runId: string, options?: {\n        signal?: AbortSignal;\n        cancelOnDisconnect?: boolean;\n        lastEventId?: string;\n        streamMode?: StreamMode | StreamMode[];\n    } | AbortSignal\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    delete(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n}\nexport declare class StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    putItem(namespace: string[], key: string, value: Record<string, unknown>, options?: {\n        index?: false | string[] | null;\n        ttl?: number | null;\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    getItem(namespace: string[], key: string, options?: {\n        refreshTtl?: boolean | null;\n        signal?: AbortSignal;\n    }): Promise<Item | null>;\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    deleteItem(namespace: string[], key: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    searchItems(namespacePrefix: string[], options?: {\n        filter?: Record<string, unknown>;\n        limit?: number;\n        offset?: number;\n        query?: string;\n        refreshTtl?: boolean | null;\n        signal?: AbortSignal;\n    }): Promise<SearchItemsResponse>;\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    listNamespaces(options?: {\n        prefix?: string[];\n        suffix?: string[];\n        maxDepth?: number;\n        limit?: number;\n        offset?: number;\n        signal?: AbortSignal;\n    }): Promise<ListNamespaceResponse>;\n}\ndeclare class UiClient extends BaseClient {\n    private static promiseCache;\n    private static getOrCached;\n    getComponent(assistantId: string, agentName: string): Promise<string>;\n}\nexport declare class Client<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> {\n    /**\n     * The client for interacting with assistants.\n     */\n    assistants: AssistantsClient;\n    /**\n     * The client for interacting with threads.\n     */\n    threads: ThreadsClient<TStateType, TUpdateType>;\n    /**\n     * The client for interacting with runs.\n     */\n    runs: RunsClient<TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * The client for interacting with cron runs.\n     */\n    crons: CronsClient;\n    /**\n     * The client for interacting with the KV store.\n     */\n    store: StoreClient;\n    /**\n     * The client for interacting with the UI.\n     * @internal Used by LoadExternalComponent and the API might change in the future.\n     */\n    \"~ui\": UiClient;\n    /**\n     * @internal Used to obtain a stable key representing the client.\n     */\n    private \"~configHash\";\n    constructor(config?: ClientConfig);\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nexport declare function getClientConfigHash(client: Client): string | undefined;\nexport {};\n"],"mappings":"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"}